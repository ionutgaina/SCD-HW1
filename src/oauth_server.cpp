/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "server.h"
#include "token.h"

using namespace std;

DB db;

AuthResponse *
auth_1_svc(AuthRequest arg1,  struct svc_req *rqstp)
{
	static AuthResponse result;

	string id = arg1.user_id;

	cout << "BEGIN " << id << " AUTHZ\n";

	if (db.clients.find(id) == db.clients.end()) {
		result.status = StatusCode::USER_NOT_FOUND_;
		result.token = "";
		return &result;
	}

	char *token = generate_access_token((char*)id.c_str());

	result.token = token;
	result.status = StatusCode::OK_;

	return &result;
}

ApproveTokenResponse *
approve_token_1_svc(ApproveTokenRequest arg1,  struct svc_req *rqstp)
{
	static ApproveTokenResponse  result;

	string approval = db.approvals.front();
	db.approvals.pop();

	if (approval == "*,-") {
		result.token = arg1.token;
		result.perms = "";
		result.status = StatusCode::OK_;
		return &result;
	}

	// SAVE APPROVAL
	db.client_tokens_approval[arg1.token] = approval;

	result.token = arg1.token;
	result.perms = (char *)approval.c_str();
	result.status = StatusCode::OK_;

	return &result;
}

OauthAccessTokenResponse *
oauth_access_token_1_svc(OauthAccessTokenRequest arg1,  struct svc_req *rqstp)
{
	static OauthAccessTokenResponse  result;

	string id = arg1.user_id;
	string token = arg1.token;
	bool is_refresh_token = arg1.is_refresh_token;

	cout << "  RequestToken = " << token << endl;

	if (!db.is_client(id)) {
		result.token = "";
		result.refresh_token = "";
		result.ttl = 0;
		result.status = StatusCode::USER_NOT_FOUND_;
		return &result;
	}

	auto& client = db.clients[id];

	if (db.client_tokens_approval.find(token) == db.client_tokens_approval.end()) {
		result.token = "";
		result.refresh_token = "";
		result.ttl = 0;
		result.status = StatusCode::REQUEST_DENIED_;
		return &result;
	}

	// UPDATE TOKEN
	client.access_token = generate_access_token((char *)token.c_str());
	client.perms = db.client_tokens_approval[token];
	client.refresh_token = "";
	client.ttl = db.token_validity;
	cout << "  AccessToken = " << client.access_token << endl;

	if (is_refresh_token) {
		client.refresh_token = generate_access_token((char *)client.access_token.c_str());
		cout << "  RefreshToken = " << client.refresh_token << endl;
	}

	result.token = (char *)client.access_token.c_str();
	result.refresh_token = (char *)client.refresh_token.c_str();
	result.ttl = client.ttl;
	result.status = StatusCode::OK_;
	return &result;
}

OauthAccessTokenResponse *
oauth_refresh_token_1_svc(OauthRefreshTokenRequest arg1,  struct svc_req *rqstp)
{
	static OauthAccessTokenResponse  result;

	string refresh_token = arg1.token;
	
	for (auto& client : db.clients) {
		auto id = client.first;

		if (client.second.refresh_token == refresh_token) {
			// UPDATE TOKENs
			cout << "BEGIN " << id << " AUTHZ REFRESH\n";

			client.second.access_token = generate_access_token((char *)refresh_token.c_str());
			cout << "  AccessToken = " << client.second.access_token << "\n";
			
			client.second.refresh_token = generate_access_token((char *)client.second.access_token.c_str());
    		cout << "  RefreshToken = " << client.second.refresh_token << "\n";
			client.second.ttl = db.token_validity;

			// CREATE RESPONSE
			result.token = (char *)client.second.access_token.c_str();
			result.refresh_token = (char *)client.second.refresh_token.c_str();
			result.ttl = client.second.ttl;
			result.status = StatusCode::OK_;
			return &result;
		}
	}

	return &result;
}

ExecuteActionResponse *
execute_action_1_svc(ExecuteActionRequest arg1,  struct svc_req *rqstp)
{
	static ExecuteActionResponse  result;

	string token = arg1.token;
	string action = arg1.action;
	string resource = arg1.resource;

	ClientData* client = nullptr;

	for (auto& c : db.clients) {
		if (c.second.access_token == token) {
			client = &c.second;
			break;
		}
	}

	if (client == nullptr) {
		cout << "DENY (" << action << "," << resource << ",,0)" << endl;
		result.status = StatusCode::PERMISSION_DENIED_;
		return &result;
	}

	if (client->ttl <= 0) {
		cout << "DENY (" << action << "," << resource << ",,0)" << endl;
		result.status = StatusCode::TOKEN_EXPIRED_;
		return &result;
	}

	client->ttl--;
	
	if (!db.find_resource(resource)) {
		cout << "DENY (" << action << "," << resource << ',' << token << ',' << client->ttl << ')' << endl;
		result.status = StatusCode::RESOURCE_NOT_FOUND_;
		return &result;
	}

	if (!db.has_approval(resource, action, client)) {
		cout << "DENY (" << action << "," << resource << ',' << token << ',' << client->ttl << ')' << endl;
		result.status = StatusCode::OPERATION_NOT_PERMITTED_;
		return &result;
	}

	cout << "PERMIT (" << action << "," << resource << ',' << token << ',' << client->ttl << ')' << endl;
	result.status = StatusCode::PERMISSION_GRANTED_;

	return &result;
}

string init_server(int argc, char **argv) {
    if (argc != 5) {
        return "Usage: " + string(argv[0]) + " <client file> <resources file> <approval file> <token validity>\n";
    }

    db = DB(argv[1], argv[2], argv[3], stoi(argv[4]));

    if (db.clients.empty() || db.resources.empty() || db.approvals.empty()) {
        return "Error: Unable to load data.\n";
    }
    
    return "";
}